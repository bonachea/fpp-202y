To: J3                                                     J3/25-xxx
From: JoR
Subject: Fortran preprocessor requirements
Date: 2025-January-24

References: 95-257 Conditional Compilation: The FCC Approach.txt
            96-063 A Fortran Preprocessor.txt
            23-192r1 F202Y Define a standard Fortran preprocessor.txt
            24-108 Preprocessor directives seen in existing Fortran
                   programs.txt
            24-109 On Fortran awareness in a Fortran preprocessor.txt
            24-177r1 Fortran preprocessor requirements.txt
            Tutorials/Preprocessor Take 2.pptx
            ISO/IEC 9899:2023 Programming languages â€” C
                   working draft N3096


1. Introduction
---------------
Many existing Fortran projects make extensive use of C preprocessor
directives and expansion. This is usually done to tailor the code to
specific environments, such as target compilers or machines.

Existing compiler implementations behave differently in the presence of
these directives, hampering portability.

This document attempts to define the requirements for a standardized
Fortran preprocessor (herein called FPP). The guiding principle is to
promote Fortran program portability by defining consistent syntax and
semantics of a subset of the C preprocessor. Some FPP behavior will need
to be different than the C preprocessor (herein called CPP) to
accommodate some Fortran idiosyncrasies.


2. The basic idea: phases before the "processor"
------------------------------------------------
The preprocessor will be a mandatory part of the language. Any file
passed to a processor may contain preprocessor directive lines.

The C standards define eight phases of the compilation process. These
phases don't prescribe the details of an implementation, but are useful
for defining in focused terms the expected behavior of implementations.

We plan to take a similar approach for defining FPP. This should
simplify the explanation of the expected behavior of any given
implementation.


3. FPP Phase 1: Line conjoining
-------------------------------
The C language defines phase 2 as a pass where continuation lines are
removed. To simplify the explanation of FPP's preprocessing phase 2, we
will define phase 1 to simply remove continuation lines seen in the
source file. This will apply to both fixed-form and free-form source
Fortran lines and preprocessor directive lines. The output of this phase
is a sequence of "logical lines", each of which may be up to 1 million
characters long. Logical lines are a sequence of strings and
comment-strings in the same order as they are encountered in the input
stream.


4. FPP Phase 2: Directive processing
------------------------------------
The directive processing phase is analogous to CPP phase 4. Preprocessor
directives are executed. Macros are expanded in non-preprocessor lines
(Fortran source lines).

The directive language accepted by FPP is based on the syntax of CPP. It
has syntax that differs from Fortran, but macros can expand to include
arbitrary Fortran tokens. It differs from C and Fortran syntax in the
following ways.

Token recognition:
    1. FPP's directives and token recognition are case sensitive.
    2. FPP treats blanks adjacent to tokens as significant, even in
       fixed-form source files.

Line continuation in directives:
    1. FPP directive lines accept backslash (\) for line continuations.
    2. FPP does not recognize fixed-form (column 6) or free-form (&)
       continuations on directive lines.

Comment handling:
    1. FPP does not recognize '!' as initiating a comment on directive
       lines. In #if and #elif directive expressions, '!' is interpreted
       as the C 'not' operator.
    2. FPP does not recognize '//' as initiating a comment on directive
       lines. '//' can be used to construct macro definitions that
       contain Fortran string concatenation.
    3. FPP recognizes /* ... */ C-style comments on directive lines.
       /* ... */ comments are not recognized in (non-directive)
       Fortran source lines.
    4. Macros are expanded in comment lines that appear to be directives
       (processor-specific, such as '!$omp', or '!$acc', or others).

Constant expressions in #if and #elif:
    1. Expressions in #if and #elif directives allow operators from
       both Fortran and CPP.
    2. Expressions in #if and #elif directives must be integer constant
       expressions as specified for CPP (with the extensions described
       below), and evaluate to INTEGER values. As in CPP, zero values
       are treated as 'false'. Non-zero values are treated as 'true'.
    3. .FALSE. and .false. are treated as the integer 0. .TRUE. and .true.
       are treated as the integer 1.
    4. Any undefined identifiers that remain after macro expansion
       (including those lexically identical to keywords or intrinsics)
       are treated as zero, as in CPP.
    5. C character constants (such as 'A', '\n') are treated as
       integer values, as they are in CPP.
    6. The Fortran operators .AND., .OR., ,NOT., =, and /= evaluate
       to the same values as the C operators &&, ||, !, ==, and !=,
       respectively.
    7. There are no KIND specifiers on integer constants in the
       preprocessor.
    8. Integer expressions in preprocessor directives are evaluated using
       the maximum precision the processor supports.


4.1. Directives accepted by the preprocessor
--------------------------------------------
The following preprocessor directives will have the same semantics
as defined in the C23 edition of the C programming language standard.
    #line
    #define  including function-like macros and those
             that uses the ellipsis notation in the parameters
    #undef
    #if, #elif, #else, #endif
    #ifdef, #ifndef, #elifdef, #elifndef
    #include
    #error
    #warning
    #pragma

Just as #include lines interpolate the source from other files, the
preprocessor will include the text from Fortran INCLUDE lines.
Text interpolated by INCLUDE lines will be treated as if it had
been included via #include.


4.2 Tokens accepted on #define directives
-----------------------------------------
    - # (stringify)
    - ## (token concatenation)
    - Any valid Fortran token
    - Any C operator allowed in a #if or #elif expression
    - Any macro names defined by the preprocessor


4.3 Operators accepted in #if and #elif expressions
---------------------------------------------------
    - The "defined" operator
    - From C: && || == != < > <= >= + / * ! & | ^ ~ ( )
    - From Fortran: = /= .AND. .OR. .NOT.


4.4 Macros defined by the preprocessor
---------------------------------------------
    __LINE__
    __FILE__
    __DATE__
    __TIME__
    __STDF__
    __VA_ARGS__  in the replacement-list of a function-like macro
      that uses the ellipsis notation in the parameters.
    __VA_OPT__  in the replacement-list of a function-like macro
      that uses the ellipsis notation in the parameters.

__STDF__ is an analog to __STDC__ in C and __cplusplus in C++.  Its primary
role is to provide preprocessor-visible and vendor-independent identification
of the underlying target language (i.e., "the processor is Fortran"), which
enables one to write multi-language header files with conditional compilation
based on language.

4.5. Fortran awareness during macro expansion
---------------------------------------------
Just as CPP does not expand tokens in strings, there are places in
Fortran lines that FPP should not recognize or expand tokens.

FPP will not expand in fixed-form
    - A token "C" or "c" in column 1.
    - Anything in column 6.


FPP will not expand tokens in either fixed- or free-form:
    - In character constants
    - In FORMAT statements
    - In the letter-spec-list in an IMPLICIT statement.


4.6 Output of Phase 2
---------------------
Similar to phase 1, the output is a sequence of logical lines where the
logical lines contain the strings representing the now-preprocessed
characters of the input file and comment-strings.
